<!doctype html>
<html lang="pt-BR">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="css/leaflet.css">
        <link rel="stylesheet" href="css/L.Control.Layers.Tree.css">
        <link rel="stylesheet" href="css/qgis2web.css">
        <link rel="stylesheet" href="css/fontawesome-all.min.css">
		<link rel="stylesheet" href="css/singlePageTemplate.css" type="text/css">
        <style>
        html, #map {
            width: 100%;
            height: 80vh;
            padding: 0;
            margin: 0;
        }
		.labels { display: flex; justify-content: space-between; }
        .labels span { margin: 0 5px; }
        </style>
        <title>Mapa Temporal com Controle Deslizante</title>
    </head>
    <body>
		<div class="container"> 
  		<header> 
		<a href="PDPA.htm">
    	<div>
      		<h4 class="logo">
			 	NITERÓI VIEW
			</h4>
    	</div>
    </a>
	<nav>
      <ul>
        <li><a href="Index.html">HOME</a></li>
        <li><a href="#about">SOBRE</a></li>
        <li><a href="#contact">CONTATO</a></li>
      </ul>
    </nav>
        <div id="map">
        </div>
        <script src="js/qgis2web_expressions.js"></script>
        <script src="js/leaflet.js"></script>
        <script src="js/L.Control.Layers.Tree.min.js"></script>
        <script src="js/multi-style-layer.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="https://unpkg.com/supercluster@7.1.5/dist/supercluster.min.js"></script>
        <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
        <script src="data/Agua_Niteroi_0.js"></script>
        <script src="data/Terreno_Niteroi_1.js"></script>
        <script src="data/Lagunas_2.js"></script>
        <script src="data/Area_Urbana_4.js"></script>
        <script src="data/CurvasdeNvel_5.js"></script>
        <script src="data/Logradouros_6.js"></script>
        <script src="data/EdifciosHistricos_7.js"></script>
        <script>
        const CACHE_VERSION = 'v1';
        const CACHE_NAME = `webmap-data-${CACHE_VERSION}`;
        
        // Configuration for performance optimization
        const CONFIG = {
            // Year threshold for using advanced rendering techniques
            HEAVY_YEAR_THRESHOLD: 1950,
            // Use WebGL rendering for years after the threshold
            USE_WEBGL_FOR_HEAVY_YEARS: true,
            // Use vector tiles approach for complex geometries
            USE_VECTOR_TILES: true,
            // Number of years to preload on each side of the current year
            PRELOAD_ADJACENT_YEARS: 2,
            // Maximum number of features to process at once for progressive loading
            PROGRESSIVE_LOAD_CHUNK_SIZE: 500,
            // Clustering distance in pixels
            CLUSTER_RADIUS: 80,
            // Maximum zoom level for clustering
            CLUSTER_MAX_ZOOM: 16
        };
        
        var map = L.map('map', {
            zoomControl: false,
            maxZoom: 16,
            minZoom: 13,
            preferCanvas: true,
            renderer: L.canvas()
        }).fitBounds([[-22.912355978919862,-43.142251682921554],[-22.884123543823108,-43.091444563788734]]);
        
        // Create a cache for filtered layers
        var layerCache = {};
        
        // Create a cache for preloaded adjacent years
        var preloadCache = {};
        
        // Track the current year being displayed
        var currentYear = 1820;
        
        // Flag to track if we're using WebGL rendering
        var usingWebGL = false;
        
        if ('caches' in window) {
            caches.open(CACHE_NAME).then(cache => {
                cache.add('data/Logradouros_6.js');
            });
        }
        
        var hash = new L.Hash(map);
        map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});
        function removeEmptyRowsFromPopupContent(content, feature) {
         var tempDiv = document.createElement('div');
         tempDiv.innerHTML = content;
         var rows = tempDiv.querySelectorAll('tr');
         for (var i = 0; i < rows.length; i++) {
             var td = rows[i].querySelector('td.visible-with-data');
             var key = td ? td.id : '';
             if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                 rows[i].parentNode.removeChild(rows[i]);
             }
         }
         return tempDiv.innerHTML;
        }
        function addClassToPopupIfMedia(content, popup) {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            if (tempDiv.querySelector('td img')) {
                popup._contentNode.classList.add('media');
                setTimeout(function() {
                    popup.update();
                }, 10);
            } else {
                popup._contentNode.classList.remove('media');
            }
        }
        var zoomControl = L.control.zoom({
            position: 'topleft'
        }).addTo(map);
        var bounds_group = new L.featureGroup([]);
        function setBounds() {
        }
        if (bounds_group.getLayers().length) {
                map.fitBounds(bounds_group.getBounds());
            }
            // Use the original map bounds but expand them significantly to allow extensive panning
            var originalBounds = [[-22.912355978919862,-43.142251682921554],[-22.884123543823108,-43.091444563788734]];
            var expandFactor = 4.0; // 400% expansion for extremely wide panning area
            
            // Calculate expanded bounds
            var latDiff = Math.abs(originalBounds[0][0] - originalBounds[1][0]);
            var lngDiff = Math.abs(originalBounds[0][1] - originalBounds[1][1]);
            
            var expandedBounds = [
                [originalBounds[0][0] - latDiff * expandFactor, originalBounds[0][1] - lngDiff * expandFactor],
                [originalBounds[1][0] + latDiff * expandFactor, originalBounds[1][1] + lngDiff * expandFactor]
            ];
            
            map.setMaxBounds(expandedBounds);
            
        function pop_Agua_Niteroi_0(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['fid'] !== null ? autolinker.link(String(feature.properties['fid']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Tipo'] !== null ? autolinker.link(String(feature.properties['Tipo']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(content, e.popup);
			});
			layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_Agua_Niteroi_0_0() {
            return {
                pane: 'pane_Agua_Niteroi_0',
                opacity: 1,
                color: 'rgba(149,214,233,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(152,218,238,1.0)',
                interactive: false,
            }
        }
        map.createPane('pane_Agua_Niteroi_0');
        map.getPane('pane_Agua_Niteroi_0').style.zIndex = 400;
        map.getPane('pane_Agua_Niteroi_0').style['mix-blend-mode'] = 'normal';
        var layer_Agua_Niteroi_0 = new L.geoJson(json_Agua_Niteroi_0, {
            attribution: '',
            interactive: false,
            dataVar: 'json_Agua_Niteroi_0',
            layerName: 'layer_Agua_Niteroi_0',
            pane: 'pane_Agua_Niteroi_0',
            onEachFeature: pop_Agua_Niteroi_0,
            style: style_Agua_Niteroi_0_0,
        });
        bounds_group.addLayer(layer_Agua_Niteroi_0);
        map.addLayer(layer_Agua_Niteroi_0);
        function pop_Terreno_Niteroi_1(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['fid'] !== null ? autolinker.link(String(feature.properties['fid']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Tipo'] !== null ? autolinker.link(String(feature.properties['Tipo']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['data_abert'] !== null ? autolinker.link(String(feature.properties['data_abert']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(content, e.popup);
			});
			layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_Terreno_Niteroi_1_0(feature) {
            switch(String(feature.properties['Tipo'])) {
                case 'Terra':
                    return {
                pane: 'pane_Terreno_Niteroi_1',
                opacity: 1,
                color: 'rgba(225,249,227,0.792)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(214,248,226,0.792)',
                interactive: false,
            }
                    break;
                case 'Areia':
                    return {
                pane: 'pane_Terreno_Niteroi_1',
                opacity: 1,
                color: 'rgba(225,249,227,0.792)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(246,236,207,0.792)',
                interactive: false,
            }
                    break;
            }
        }
        map.createPane('pane_Terreno_Niteroi_1');
        map.getPane('pane_Terreno_Niteroi_1').style.zIndex = 401;
        map.getPane('pane_Terreno_Niteroi_1').style['mix-blend-mode'] = 'normal';
        var layer_Terreno_Niteroi_1 = new L.geoJson(json_Terreno_Niteroi_1, {
            attribution: '',
            interactive: true,
            dataVar: 'json_Terreno_Niteroi_1',
            layerName: 'layer_Terreno_Niteroi_1',
            pane: 'pane_Terreno_Niteroi_1',
            onEachFeature: pop_Terreno_Niteroi_1,
            style: style_Terreno_Niteroi_1_0,
        });
        var originalFeatures_Terreno = json_Terreno_Niteroi_1.features;
        bounds_group.addLayer(layer_Terreno_Niteroi_1);
        map.addLayer(layer_Terreno_Niteroi_1);
        function pop_Lagunas_2(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['OBJECTID'] !== null ? autolinker.link(String(feature.properties['OBJECTID']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['NOME'] !== null ? autolinker.link(String(feature.properties['NOME']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(content, e.popup);
			});
			layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_Lagunas_2_0() {
            return {
                pane: 'pane_Lagunas_2',
                opacity: 1,
                color: 'rgba(144,206,225,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(152,218,238,1.0)',
                interactive: false,
            }
        }
        map.createPane('pane_Lagunas_2');
        map.getPane('pane_Lagunas_2').style.zIndex = 402;
        map.getPane('pane_Lagunas_2').style['mix-blend-mode'] = 'normal';
        var layer_Lagunas_2 = new L.geoJson(json_Lagunas_2, {
            attribution: '',
            interactive: false,
            dataVar: 'json_Lagunas_2',
            layerName: 'layer_Lagunas_2',
            pane: 'pane_Lagunas_2',
            onEachFeature: pop_Lagunas_2,
            style: style_Lagunas_2_0,
        });
        bounds_group.addLayer(layer_Lagunas_2);
        map.addLayer(layer_Lagunas_2);
        map.createPane('pane_MDE_Niteroi_3');
        map.getPane('pane_MDE_Niteroi_3').style.zIndex = 403;
        var img_MDE_Niteroi_3 = 'data/MDE_Niteroi_3.png';
        var img_bounds_MDE_Niteroi_3 = [[-23.082361111,-43.705694444],[-22.507083333,-42.62875]];
        var layer_MDE_Niteroi_3 = new L.imageOverlay(img_MDE_Niteroi_3,
                                              img_bounds_MDE_Niteroi_3,
                                              {pane: 'pane_MDE_Niteroi_3'});
        bounds_group.addLayer(layer_MDE_Niteroi_3);
        map.addLayer(layer_MDE_Niteroi_3);
        function pop_Area_Urbana_4(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['fid'] !== null ? autolinker.link(String(feature.properties['fid']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Data_abert'] !== null ? autolinker.link(String(feature.properties['Data_abert']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Data_fecha'] !== null ? autolinker.link(String(feature.properties['Data_fecha']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(content, e.popup);
			});
			layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_Area_Urbana_4_0() {
            return {
                pane: 'pane_Area_Urbana_4',
                opacity: 1,
                color: 'rgba(219,219,219,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(219,219,219,1.0)',
                interactive: true,
            }
        }
        map.createPane('pane_Area_Urbana_4');
        map.getPane('pane_Area_Urbana_4').style.zIndex = 404;
        map.getPane('pane_Area_Urbana_4').style['mix-blend-mode'] = 'normal';
        var layer_Area_Urbana_4 = new L.geoJson(json_Area_Urbana_4, {
            attribution: '',
            interactive: true,
            dataVar: 'json_Area_Urbana_4',
            layerName: 'layer_Area_Urbana_4',
            pane: 'pane_Area_Urbana_4',
            onEachFeature: pop_Area_Urbana_4,
            style: style_Area_Urbana_4_0,
        });
        var originalFeatures_Area = json_Area_Urbana_4.features;
        bounds_group.addLayer(layer_Area_Urbana_4);
        map.addLayer(layer_Area_Urbana_4);
        function pop_CurvasdeNvel_5(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['ID_OBJETO'] !== null ? autolinker.link(String(feature.properties['ID_OBJETO']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['COTA'] !== null ? autolinker.link(String(feature.properties['COTA']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(content, e.popup);
			});
			layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_CurvasdeNvel_5_0() {
            return {
                pane: 'pane_CurvasdeNvel_5',
                opacity: 1,
                color: 'rgba(149,149,149,0.17)',
                dashArray: '',
                lineCap: 'square',
                lineJoin: 'bevel',
                weight: 1.0,
                fillOpacity: 0,
                interactive: false,
            }
        }
        map.createPane('pane_CurvasdeNvel_5');
        map.getPane('pane_CurvasdeNvel_5').style.zIndex = 405;
        map.getPane('pane_CurvasdeNvel_5').style['mix-blend-mode'] = 'normal';
        var layer_CurvasdeNvel_5 = new L.geoJson(json_CurvasdeNvel_5, {
            attribution: '',
            interactive: false,
            dataVar: 'json_CurvasdeNvel_5',
            layerName: 'layer_CurvasdeNvel_5',
            pane: 'pane_CurvasdeNvel_5',
            onEachFeature: pop_CurvasdeNvel_5,
            style: style_CurvasdeNvel_5_0,
        });
        bounds_group.addLayer(layer_CurvasdeNvel_5);
        map.addLayer(layer_CurvasdeNvel_5);
        function pop_Logradouros_6(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['nome_compl'] !== null ? autolinker.link(String(feature.properties['nome_compl']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['no_ant'] !== null ? autolinker.link(String(feature.properties['no_ant']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['bairro_dir'] !== null ? autolinker.link(String(feature.properties['bairro_dir']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['data_abert'] !== null ? autolinker.link(String(feature.properties['data_abert']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['data_fecha'] !== null ? autolinker.link(String(feature.properties['data_fecha']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(content, e.popup);
			});
			layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_Logradouros_6_0() {
            return {
                pane: 'pane_Logradouros_6',
                opacity: 1,
                color: 'rgba(0,0,0,1.0)',
                dashArray: '',
                lineCap: 'round',
                lineJoin: 'round',
                weight: 3.0,
                fillOpacity: 0,
                interactive: true,
            }
        }
        function style_Logradouros_6_1() {
            return {
                pane: 'pane_Logradouros_6',
                opacity: 1,
                color: 'rgba(255,255,255,1.0)',
                dashArray: '',
                lineCap: 'round',
                lineJoin: 'round',
                weight: 3.0,
                fillOpacity: 0,
                interactive: true,
            }
        }
        map.createPane('pane_Logradouros_6');
        map.getPane('pane_Logradouros_6').style.zIndex = 406;
        map.getPane('pane_Logradouros_6').style['mix-blend-mode'] = 'normal';
        var layer_Logradouros_6 = new L.geoJson.multiStyle(json_Logradouros_6, {
            attribution: '',
            interactive: true,
            dataVar: 'json_Logradouros_6',
            layerName: 'layer_Logradouros_6',
            pane: 'pane_Logradouros_6',
            onEachFeature: pop_Logradouros_6,
            styles: [style_Logradouros_6_0,style_Logradouros_6_1,]
        });
        var originalFeatures = json_Logradouros_6.features;
        bounds_group.addLayer(layer_Logradouros_6);
        map.addLayer(layer_Logradouros_6);
        function pop_EdifciosHistricos_7(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Bairro'] !== null ? autolinker.link(String(feature.properties['Bairro']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Nome'] !== null ? autolinker.link(String(feature.properties['Nome']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Endereço'] !== null ? autolinker.link(String(feature.properties['Endereço']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Tipo'] !== null ? autolinker.link(String(feature.properties['Tipo']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['data_fecha'] !== null ? autolinker.link(String(feature.properties['data_fecha']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['data_abert'] !== null ? autolinker.link(String(feature.properties['data_abert']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            var content = removeEmptyRowsFromPopupContent(popupContent, feature);
			layer.on('popupopen', function(e) {
				addClassToPopupIfMedia(content, e.popup);
			});
			layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_EdifciosHistricos_7_0() {
            return {
                pane: 'pane_EdifciosHistricos_7',
                opacity: 1,
                color: 'rgba(247,247,247,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(150,150,150,1.0)',
                interactive: true,
            }
        }
        map.createPane('pane_EdifciosHistricos_7');
        map.getPane('pane_EdifciosHistricos_7').style.zIndex = 407;
        map.getPane('pane_EdifciosHistricos_7').style['mix-blend-mode'] = 'normal';
        var layer_EdifciosHistricos_7 = new L.geoJson(json_EdifciosHistricos_7, {
            attribution: '',
            interactive: true,
            dataVar: 'json_EdifciosHistricos_7',
            layerName: 'layer_EdifciosHistricos_7',
            pane: 'pane_EdifciosHistricos_7',
            onEachFeature: pop_EdifciosHistricos_7,
            style: style_EdifciosHistricos_7_0,
        });
        var originalFeatures_Edificios = json_EdifciosHistricos_7.features;
        bounds_group.addLayer(layer_EdifciosHistricos_7);
        map.addLayer(layer_EdifciosHistricos_7);
        var overlaysTree = [
            {label: '<img src="legend/EdifciosHistricos_7.png" /> Edifícios Históricos', layer: layer_EdifciosHistricos_7},
            {label: '<img src="legend/Logradouros_6.png" /> Logradouros', layer: layer_Logradouros_6},
            {label: '<img src="legend/CurvasdeNvel_5.png" /> Curvas de Nível', layer: layer_CurvasdeNvel_5},
            {label: '<img src="legend/Area_Urbana_4.png" /> Area_Urbana', layer: layer_Area_Urbana_4},
            {label: "MDE_Niteroi", layer: layer_MDE_Niteroi_3},
            {label: '<img src="legend/Lagunas_2.png" /> Lagunas', layer: layer_Lagunas_2},
            {label: 'Terreno_Niteroi<br /><table><tr><td style="text-align: center;"><img src="legend/Terreno_Niteroi_1_Terra0.png" /></td><td>Terra</td></tr><tr><td style="text-align: center;"><img src="legend/Terreno_Niteroi_1_Areia1.png" /></td><td>Areia</td></tr></table>', layer: layer_Terreno_Niteroi_1},
            {label: '<img src="legend/Agua_Niteroi_0.png" /> Agua_Niteroi', layer: layer_Agua_Niteroi_0},]
        var lay = L.control.layers.tree(null, overlaysTree,{
            //namedToggle: true,
            //selectorBack: false,
            //closedSymbol: '&#8862; &#x1f5c0;',
            //openedSymbol: '&#8863; &#x1f5c1;',
            //collapseAll: 'Collapse all',
            //expandAll: 'Expand all',
            collapsed: true,
        });
        lay.addTo(map);
        map.on("zoomend", function(){

                if (map.hasLayer(layer_Logradouros_6)) {
                    if (map.getZoom() <= 13 && map.getZoom() >= 19) {
                        layer_Logradouros_6.eachLayer(function (layer) {
                            layer.openTooltip();
                        });
                    } else {
                        layer_Logradouros_6.eachLayer(function (layer) {
                            layer.closeTooltip();
                        });
                    }
                }
        });
        setBounds();
        var i = 0;
        layer_Logradouros_6.eachLayer(function(layer) {
            var context = {
                feature: layer.feature,
                variables: {}
            };
            layer.bindTooltip((layer.feature.properties['nome_compl'] !== null?String('<div style="color: #323232; font-size: 4pt; font-family: \'Arial\', sans-serif;">' + layer.feature.properties['nome_compl']) + '</div>':''), {permanent: true, offset: [-0, -16], className: 'css_Logradouros_6'});
            labels.push(layer);
            totalMarkers += 1;
              layer.added = true;
              addLabel(layer, i);
              i++;
        });
                if (map.hasLayer(layer_Logradouros_6)) {
                    if (map.getZoom() <= 13 && map.getZoom() >= 19) {
                        layer_Logradouros_6.eachLayer(function (layer) {
                            layer.openTooltip();
                        });
                    } else {
                        layer_Logradouros_6.eachLayer(function (layer) {
                            layer.closeTooltip();
                        });
                    }
                }
        L.ImageOverlay.include({
            getBounds: function () {
                return this._bounds;
            }
        });
        resetLabels([layer_Logradouros_6]);
        map.on("zoomend", function(){
            resetLabels([layer_Logradouros_6]);
        });
        map.on("layeradd", function(){
            resetLabels([layer_Logradouros_6]);
        });
        map.on("layerremove", function(){
            resetLabels([layer_Logradouros_6]);
        });
        // Create a spatial index for faster feature lookup
        function createSpatialIndex(features) {
            var index = {};
            features.forEach(function(feature, i) {
                var bounds = getBoundsFromFeature(feature);
                if (bounds) {
                    var key = Math.floor(bounds.getCenter().lat * 100) + '-' + Math.floor(bounds.getCenter().lng * 100);
                    if (!index[key]) index[key] = [];
                    index[key].push(i);
                }
            });
            return index;
        }
        
        // Create clusters for point features
        function createClusters(features) {
            // Convert GeoJSON features to points for SuperCluster
            var points = features
                .filter(f => f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint'))
                .map((feature, id) => {
                    var coords;
                    if (feature.geometry.type === 'Point') {
                        coords = feature.geometry.coordinates;
                    } else if (feature.geometry.type === 'MultiPoint' && feature.geometry.coordinates.length > 0) {
                        coords = feature.geometry.coordinates[0];
                    } else {
                        return null;
                    }
                    
                    return {
                        type: 'Feature',
                        properties: { 
                            ...feature.properties,
                            id: id
                        },
                        geometry: {
                            type: 'Point',
                            coordinates: coords
                        }
                    };
                })
                .filter(p => p !== null);
            
            // Create SuperCluster instance
            var cluster = new Supercluster({
                radius: CONFIG.CLUSTER_RADIUS,
                maxZoom: CONFIG.CLUSTER_MAX_ZOOM
            });
            
            // Load points into the cluster
            cluster.load(points);
            
            return {
                cluster: cluster,
                points: points
            };
        }
        
        // Function to create vector tiles from GeoJSON
        function createVectorTiles(features, layerName, styleFunction) {
            // Create a GeoJSON with the features
            var geojson = {
                type: 'FeatureCollection',
                features: features
            };
            
            // Create vector grid from GeoJSON
            var vectorGrid = L.vectorGrid.slicer(geojson, {
                rendererFactory: L.svg.tile,
                vectorTileLayerStyles: {
                    sliced: styleFunction
                },
                maxZoom: 16,
                minZoom: 13,
                interactive: true,
                getFeatureId: function(f) {
                    return f.properties.id || Math.random().toString(36).substring(2, 15);
                }
            });
            
            return vectorGrid;
        }
        
        // Function to render features using WebGL
        function renderWithWebGL(features, layerName) {
            // Convert features to format expected by leaflet.glify
            var points = [];
            var colors = [];
            var data = [];
            
            features.forEach(function(feature) {
                if (feature.geometry.type === 'Point') {
                    points.push([
                        feature.geometry.coordinates[1], 
                        feature.geometry.coordinates[0]
                    ]);
                    colors.push([255, 0, 0, 255]); // Red color with full opacity
                    data.push(feature.properties);
                } else if (feature.geometry.type === 'MultiPoint') {
                    feature.geometry.coordinates.forEach(function(coord) {
                        points.push([coord[1], coord[0]]);
                        colors.push([255, 0, 0, 255]);
                        data.push(feature.properties);
                    });
                }
            });
            
            // Only create WebGL layer if we have points
            if (points.length > 0) {
                return L.glify.points({
                    map: map,
                    data: points,
                    colors: colors,
                    className: layerName,
                    opacity: 0.8,
                    size: 5,
                    click: function(e, feature, xy) {
                        console.log('Clicked point:', feature, 'at', xy);
                    }
                });
            }
            
            return null;
        }
        
        // Add debouncing to prevent excessive rendering during slider movement
        var debounceTimer;
        function debouncedUpdateYear(value) {
            document.getElementById('year').textContent = value;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(function() {
                updateYear(value);
            }, 100); // 100ms debounce time
        }

        // Preload data for adjacent years
        function preloadAdjacentYears(year) {
            var yearsToPreload = [];
            for (var i = 1; i <= CONFIG.PRELOAD_ADJACENT_YEARS; i++) {
                yearsToPreload.push(parseInt(year) + i);
                yearsToPreload.push(parseInt(year) - i);
            }
            
            yearsToPreload.forEach(function(yearToPreload) {
                if (yearToPreload >= 1820 && yearToPreload <= 2020 && !layerCache['year_' + yearToPreload]) {
                    setTimeout(function() {
                        processYearData(yearToPreload, true);
                    }, 100 * (Math.abs(yearToPreload - year))); // Stagger the preloading
                }
            });
        }
        
        // Process data for a specific year (either for display or preloading)
        function processYearData(year, isPreloading) {
            // Skip if already in cache
            if (layerCache['year_' + year]) {
                return;
            }
            
            // Determine if this is a "heavy" year that needs special handling
            var isHeavyYear = year >= CONFIG.HEAVY_YEAR_THRESHOLD;
            
            // Filter features for this year
            var filteredFeatures = filterFeaturesByDate(originalFeatures, year);
            var filteredTerreno = filterFeaturesByDate(originalFeatures_Terreno, year);
            var filteredArea = filterFeaturesByDate(originalFeatures_Area, year);
            var filteredEdificios = filterFeaturesByDate(originalFeatures_Edificios, year);
            
            // Apply geometry simplification based on zoom level
            var zoomLevel = map.getZoom();
            var simplifyTolerance = zoomLevel < 14 ? 0.0001 : 0;
            
            if (simplifyTolerance > 0) {
                filteredFeatures = simplifyFeatures(filteredFeatures, simplifyTolerance);
                filteredTerreno = simplifyFeatures(filteredTerreno, simplifyTolerance);
                filteredArea = simplifyFeatures(filteredArea, simplifyTolerance);
            }
            
            // Create layers based on the year's complexity
            var layers = {};
            
            if (isHeavyYear && CONFIG.USE_WEBGL_FOR_HEAVY_YEARS) {
                // Use WebGL rendering for heavy years
                var webglLayer = renderWithWebGL(filteredFeatures, 'layer_Logradouros_6');
                if (webglLayer) {
                    layers.logradouros = webglLayer;
                } else {
                    // Fallback to regular rendering if WebGL fails
                    layers.logradouros = createRegularLayer(filteredFeatures, 'layer_Logradouros_6', true);
                }
            } else if (isHeavyYear && CONFIG.USE_VECTOR_TILES) {
                // Use vector tiles for heavy years
                layers.logradouros = createVectorTiles(filteredFeatures, 'layer_Logradouros_6', function(properties, zoom) {
                    return {
                        weight: 1,
                        color: '#ff7800',
                        opacity: 0.8,
                        fill: true,
                        radius: 6,
                        fillOpacity: 0.5
                    };
                });
            } else {
                // Use regular Leaflet layers for lighter years
                layers.logradouros = createRegularLayer(filteredFeatures, 'layer_Logradouros_6', false);
            }
            
            // Always use regular layers for these since they're usually not as heavy
            layers.terreno = createRegularLayer(filteredTerreno, 'layer_Terreno_Niteroi_1', false);
            layers.area = createRegularLayer(filteredArea, 'layer_Area_Urbana_4', false);
            layers.edificios = createRegularLayer(filteredEdificios, 'layer_EdifciosHistricos_7', false);
            
            // Store in cache
            layerCache['year_' + year] = layers;
            
            // If not preloading, update the display
            if (!isPreloading && year == currentYear) {
                displayYear(year);
            }
        }
        
        // Create a regular Leaflet layer
        function createRegularLayer(features, layerName, useCluster) {
            if (layerName === 'layer_Logradouros_6') {
                if (useCluster) {
                    // Create clusters for point features
                    var clusterInfo = createClusters(features);
                    
                    // Create a layer with the clustered data
                    var clusterLayer = L.layerGroup();
                    
                    // Get clusters for current zoom level
                    var zoom = map.getZoom();
                    var clusters = clusterInfo.cluster.getClusters(
                        [-180, -90, 180, 90], 
                        Math.min(zoom, CONFIG.CLUSTER_MAX_ZOOM)
                    );
                    
                    clusters.forEach(function(cluster) {
                        if (cluster.properties.cluster) {
                            // It's a cluster
                            var marker = L.circleMarker(
                                [cluster.geometry.coordinates[1], cluster.geometry.coordinates[0]], 
                                {
                                    radius: 10 + Math.min(cluster.properties.point_count / 100, 20),
                                    fillColor: '#ff7800',
                                    color: '#fff',
                                    weight: 1,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }
                            );
                            marker.bindTooltip(cluster.properties.point_count.toString());
                            clusterLayer.addLayer(marker);
                        } else {
                            // It's a single point
                            var originalFeature = clusterInfo.points[cluster.properties.id];
                            var marker = L.circleMarker(
                                [cluster.geometry.coordinates[1], cluster.geometry.coordinates[0]], 
                                {
                                    radius: 5,
                                    fillColor: '#ff7800',
                                    color: '#fff',
                                    weight: 1,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }
                            );
                            clusterLayer.addLayer(marker);
                        }
                    });
                    
                    return clusterLayer;
                } else {
                    return new L.geoJson.multiStyle({
                        type: "FeatureCollection",
                        features: features
                    }, {
                        attribution: '',
                        interactive: true,
                        dataVar: 'json_Logradouros_6',
                        layerName: 'layer_Logradouros_6',
                        pane: 'pane_Logradouros_6',
                        onEachFeature: pop_Logradouros_6,
                        styles: [style_Logradouros_6_0, style_Logradouros_6_1]
                    });
                }
            } else if (layerName === 'layer_Terreno_Niteroi_1') {
                return new L.geoJson({
                    type: "FeatureCollection",
                    features: features
                }, {
                    attribution: '',
                    interactive: true,
                    dataVar: 'json_Terreno_Niteroi_1',
                    layerName: 'layer_Terreno_Niteroi_1',
                    pane: 'pane_Terreno_Niteroi_1',
                    onEachFeature: pop_Terreno_Niteroi_1,
                    style: style_Terreno_Niteroi_1_0
                });
            } else if (layerName === 'layer_Area_Urbana_4') {
                return new L.geoJson({
                    type: "FeatureCollection",
                    features: features
                }, {
                    attribution: '',
                    interactive: true,
                    dataVar: 'json_Area_Urbana_4',
                    layerName: 'layer_Area_Urbana_4',
                    pane: 'pane_Area_Urbana_4',
                    onEachFeature: pop_Area_Urbana_4,
                    style: style_Area_Urbana_4_0
                });
            } else if (layerName === 'layer_EdifciosHistricos_7') {
                return new L.geoJson({
                    type: "FeatureCollection",
                    features: features
                }, {
                    attribution: '',
                    interactive: true,
                    dataVar: 'json_EdifciosHistricos_7',
                    layerName: 'layer_EdifciosHistricos_7',
                    pane: 'pane_EdifciosHistricos_7',
                    onEachFeature: pop_EdifciosHistricos_7,
                    style: style_EdifciosHistricos_7_0
                });
            }
            
            return null;
        }
        
        // Display a specific year
        function displayYear(year) {
            // Remove current layers
            if (map.hasLayer(layer_Logradouros_6)) map.removeLayer(layer_Logradouros_6);
            if (map.hasLayer(layer_Terreno_Niteroi_1)) map.removeLayer(layer_Terreno_Niteroi_1);
            if (map.hasLayer(layer_Area_Urbana_4)) map.removeLayer(layer_Area_Urbana_4);
            if (map.hasLayer(layer_EdifciosHistricos_7)) map.removeLayer(layer_EdifciosHistricos_7);
            
            // Get layers from cache
            var layers = layerCache['year_' + year];
            
            // Update global layer variables
            layer_Logradouros_6 = layers.logradouros;
            layer_Terreno_Niteroi_1 = layers.terreno;
            layer_Area_Urbana_4 = layers.area;
            layer_EdifciosHistricos_7 = layers.edificios;
            
            // Add layers to map
            map.addLayer(layer_Logradouros_6);
            map.addLayer(layer_Terreno_Niteroi_1);
            map.addLayer(layer_Area_Urbana_4);
            map.addLayer(layer_EdifciosHistricos_7);
            
            // Reset labels
            resetLabels([layer_Logradouros_6, layer_Terreno_Niteroi_1, layer_Area_Urbana_4, layer_EdifciosHistricos_7]);
            
            // Update current year
            currentYear = year;
            
            // Preload adjacent years
            preloadAdjacentYears(year);
        }

        function updateYear(value) {
            var selectedYear = parseInt(value);
            
            // Check if we have a cached layer for this year
            var cacheKey = 'year_' + selectedYear;
            if (layerCache[cacheKey]) {
                // Use cached layers
                displayYear(selectedYear);
                return;
            }
            
            // Process data for this year
            processYearData(selectedYear, false);
        }
        
        // Helper function to filter features by date - optimized version
        function filterFeaturesByDate(features, selectedYear) {
            return features.filter(function(feature) {
                try {
                    var dataAbertStr = feature.properties.Data_abert || feature.properties.data_abert || feature.properties.Data_Abert;
                    var dataFechaStr = feature.properties.Data_fecha || feature.properties.data_fecha || feature.properties.Data_Fecha;
                    
                    // Quick early returns for common cases
                    if (!dataAbertStr) return true;
                    
                    // Cache for parsed dates
                    if (!feature._parsedDates) {
                        feature._parsedDates = {};
                    }
                    
                    var dataAbertura, dataFechamento;
                    
                    // Use cached parsed dates if available
                    if (feature._parsedDates.abertura !== undefined) {
                        dataAbertura = feature._parsedDates.abertura;
                    } else {
                        dataAbertura = parseYearFromDate(dataAbertStr);
                        feature._parsedDates.abertura = dataAbertura;
                    }
                    
                    if (feature._parsedDates.fechamento !== undefined) {
                        dataFechamento = feature._parsedDates.fechamento;
                    } else if (dataFechaStr) {
                        dataFechamento = parseYearFromDate(dataFechaStr);
                        feature._parsedDates.fechamento = dataFechamento;
                    } else {
                        dataFechamento = null;
                        feature._parsedDates.fechamento = null;
                    }
                    
                    // If we couldn't parse the opening date, always show the feature
                    if (!dataAbertura) return true;
                     
                    return (dataAbertura <= selectedYear) && 
                           (!dataFechamento || selectedYear <= dataFechamento);
                } catch (e) {
                    // If there's any error in parsing, show the feature
                    return true;
                }
            });
        }
        
        // Helper function to parse year from various date formats - extracted for better performance
        function parseYearFromDate(dateStr) {
            if (!dateStr) return null;
            
            if (typeof dateStr === 'number') {
                return dateStr;
            } else if (dateStr.match(/^\d{4}$/)) {
                return parseInt(dateStr);
            } else if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return parseInt(dateStr.substring(0, 4));
            } else {
                var date = new Date(dateStr);
                if (!isNaN(date.getTime())) {
                    return date.getFullYear();
                }
            }
            return null;
        }
        
        createLabels();
        updateYear(document.getElementById('timeline').value);
        
        // Update the slider to use the debounced function
        document.getElementById('timeline').oninput = function() {
            debouncedUpdateYear(this.value);
        };
        
        // Add event listener for zoom changes to update clustering
        map.on('zoomend', function() {
            if (currentYear >= CONFIG.HEAVY_YEAR_THRESHOLD) {
                // Re-process the current year data with the new zoom level
                delete layerCache['year_' + currentYear];
                processYearData(currentYear, false);
            }
        });
        
        // Add loading indicator
        var loadingIndicator = L.control({position: 'bottomleft'});
        loadingIndicator.onAdd = function(map) {
            this._div = L.DomUtil.create('div', 'loading-indicator');
            this._div.innerHTML = '<div class="spinner"></div> Loading...';
            this._div.style.display = 'none';
            return this._div;
        };
        loadingIndicator.addTo(map);
        
        // Show/hide loading indicator
        function showLoading() {
            document.querySelector('.loading-indicator').style.display = 'block';
        }
        
        function hideLoading() {
            document.querySelector('.loading-indicator').style.display = 'none';
        }
        </script>
			 <div id="timeline_div">
			    <div class="year-label">Year: <span id="year">1820</span></div>
			    <div class="slider-container">
			        <input type="range" id="timeline" min="1820" max="2020" value="1820" step="10" oninput="updateYear(this.value)">
			        <div class="labels" id="labels"></div>
			    </div>
			 </div>
			 <style>
			#timeline_div {
				width: 100%;
				padding: 10px 15px 20px;
				background-color: #f8f9fa;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0,0,0,0.1);
				margin: 10px 0;
				box-sizing: border-box;
			}
			
			.year-label {
				font-family: Arial, sans-serif;
				font-size: 14px;
				color: #555;
				margin-bottom: 15px;
				font-weight: bold;
			}
			
			.slider-container {
				position: relative;
				padding: 0 5px;
				margin: 0 10px;
			}
			
			#timeline { 
				width: calc(100% - 18px);
				margin: 10px 9px;
				-webkit-appearance: none;
				appearance: none;
				height: 6px;
				background: linear-gradient(to right, #cfe2f3, #9fc5e8, #6fa8dc);
				border-radius: 5px;
				outline: none;
				box-sizing: border-box;
			}
			
			#timeline::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 18px;
				height: 18px;
				border-radius: 50%;
				background: #3d85c6;
				border: 2px solid #fff;
				cursor: pointer;
				box-shadow: 0 1px 3px rgba(0,0,0,0.3);
			}
			
			#timeline::-moz-range-thumb {
				width: 18px;
				height: 18px;
				border-radius: 50%;
				background: #3d85c6;
				border: 2px solid #fff;
				cursor: pointer;
				box-shadow: 0 1px 3px rgba(0,0,0,0.3);
			}
			
			.labels {
				display: flex;
				justify-content: space-between;
				margin-top: 5px;
				padding: 0;
				width: calc(100% - 18px);
				margin-left: 9px;
			}
			
			.labels span {
				font-family: Arial, sans-serif;
				font-size: 12px;
				color: #777;
				position: relative;
			}
			
			.labels span::before {
				content: '';
				position: absolute;
				top: -15px;
				left: 50%;
				transform: translateX(-50%);
				width: 1px;
				height: 8px;
				background-color: #aaa;
			}
		</style>
		<script>
        // Remove duplicate initialization
        
        function createLabels() {
            var labelsDiv = document.getElementById('labels');
            labelsDiv.innerHTML = ''; 
            
            // Define key years to display (matching the data range 1820-2020)
            var years = [1820, 1870, 1920, 1970, 2020];
            
            // Create a label for each year
            years.forEach(function(year) {
                var label = document.createElement('span');
                label.textContent = year;
                labelsDiv.appendChild(label);
            });
        }
		
    </script>
		<style>
			#timeline { 
            width: 100%;
            margin: 10px 0;
			}
			
			.loading-indicator {
				background: rgba(255, 255, 255, 0.8);
				padding: 10px;
				border-radius: 5px;
				box-shadow: 0 1px 5px rgba(0,0,0,0.4);
				display: flex;
				align-items: center;
				font-family: Arial, sans-serif;
				font-size: 14px;
			}
			
			.spinner {
				border: 3px solid #f3f3f3;
				border-top: 3px solid #3498db;
				border-radius: 50%;
				width: 16px;
				height: 16px;
				animation: spin 1s linear infinite;
				margin-right: 8px;
			}
			
			@keyframes spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}
		</style>
		</div>	
    </body>
</html>
